\documentclass[a4paper, 12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage[left = 2cm, top = 1cm, right = 2cm, bottom = 2cm]{geometry}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{eufrak}

\newtheorem*{definition}{Определение}

\lstloadlanguages{C,[ANSI]C++}%,Clean,make,Fortran}%Загружаемые языки
\lstset{extendedchars=false,
        breaklines=true, %автоперенос длинных линий
        breakatwhitespace=true}
\graphicspath{{pic/}}
\titleformat{\chapter}[block]{\color{black}\Large\bfseries\filcenter}{}{1em}{}
\setcounter{secnumdepth}{0}

\begin{document}
\title{Основания алгебраического подхода к синтезу корректных алгоритмов}
\author{Лектор --- Рудаков К.В.\\ Наборщик --- Старожилец В.М.}
\date{}
\maketitle

\tableofcontents

\chapter{Лекция 1}
\section{Введение}
Данные лекции рассматривают общую задачу машинного обучения без привязки к конкретным методам и подход к синтезу корректных алгоритмов для её решения. Они являются чем-то сродни взгляда сверху.

В первую очередь следует сформулировать задачу машинного обучения в общем виде. По сути это задача построения такого алгоритма, который реализует отображение из множества начальных информаций в множество конечных информаций.

\begin{definition} 
Символом $\mathfrak{I_i}$ (читается <<И инишл>>) будем обозначать множество начальных информаций, например, симптомы болезни. 
\end{definition}

\begin{definition} 
Символом $\mathfrak{I_f}$ (читается <<И файнал>>) будем обозначать множество конечных информаций, например, диагноз. 
\end{definition}

Таким образом, на формальном языке нам требуется найти такой алгоритм $A$, что он осуществляет отображение $\mathfrak{I_i} \xrightarrow{A} \mathfrak{I_f}$. Пока что задача стоит так, что нам нужно просто найти отображение, реализуемое некоторым алгоритмом, из одного множества в другое, причём абсолютно неважно какое. В такой постановке у нас нет каких-либо ограничений на искомый алгоритм и даже просто случайный выбор решает эту задачу. Поэтому вводятся дополнительные ограничения на допустимые алгоритмы. Итак,

\begin{definition} 
$\mathfrak{M}^* = \{A|\ A:\  \mathfrak{I_i}\xrightarrow{A}\mathfrak{I_f}\}$ множество всех алгоритмов, осуществляющих отображение из $\mathfrak{I_i}$ в $\mathfrak{I_f}$. 
\end{definition}

\begin{definition} 
$I_{str}$ --- структурная информация, Условия/требования, накладываемые на $A$. 
\end{definition}

\begin{definition} 
$\mathfrak{M}(I_{str})$ --- некоторое подмножество $\mathfrak{M}^*$, удовлетворяющее $I_{str}$. 
\end{definition}

Теперь у нас есть некоторый механизм ($I_{str}$), позволяющий накладывать дополнительные ограничения на нашу задачу.

\begin{definition}[Допустимое отображение]
Любое отображение из множества $\mathfrak{M}(I_{str})$ является допустимым. 
\end{definition}

\begin{definition}[Задача Z] 
Построить алгоритм, реализующий допустимое отображение. \end{definition}

\begin{definition}[Корректный алгоритм] 
\emph{Любой} алгоритм реализующий \emph{любое} допустимое отображение называется корректным. 
\end{definition}

В такой формулировке очевидно, что необходимое и достаточное условие разрешимости задачи~--- это $\mathfrak{M}(I_{str})\neq\emptyset$, а единственности решения: $|\mathfrak{M}(I_{str})| = 1$. Заметим также, что в данной формулировке корректный алгоритм~ --- это алгоритм, не допускающий ни одной ошибки ($\mathfrak{M}(I_{str})$~--- множество алгоритмов не допускающих ошибок)! Однако, можно поставить условия несколько мягче, и дать возможность алгоритмам ошибаться.

\section{Поиск решения задачи}
Корректный алгоритм надо как-то искать, в связи с этим введем ещё одно понятие.

\begin{definition} 
$\mathfrak{M}(\pi)$~--- некоторое параметрическое семейство отображений. 
\end{definition}

После того, как мы выбрали некоторое $\mathfrak{M}(\pi)$ и впоследствии взяв там какое-нибудь отображение за начальное попытаться попасть в $\mathfrak{M}(I_{str})$. Это возможно если данные семейства пересекаются. Тут нас ждёт дилемма - с одной стороны чем сложнее наше семейство тем выше шанс что оно пересекается с семейством $\mathfrak{M}(I_{str})$, но попасть в это пересечение если $\mathfrak{M}(\pi)$ сложное может быть очень затратно, причём всегда остаётся вероятность, что мы с $\mathfrak{M}(I_{str})$ не пересекаемся. Тут используют идею расширения множества.

\begin{definition} 
Пусть $f$~--- некоторая операция над множеством $\mathfrak{M}^*$. Тогда $f(\mathfrak{M}(\pi))$~--- расширение множества $\mathfrak{M}(\pi)$. 
\end{definition}

Таким образом, мы стараемся расширить некоторое простое множество до пересечения с $\mathfrak{M}(I_{str})$. Однако, не любая функция $f$ нам подходит ведь может получиться, что мы расширились до <<сложного>> множества. Важным является то, что $f$ мы выбираем сами и можем выбрать его так, чтобы искать нужный алгоритм было не слишком сложно. (какая то ересь получилась. особенно в конце)

\end{document}