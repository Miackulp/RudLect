\documentclass[a4paper, 12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage[left = 2cm, top = 1cm, right = 2cm, bottom = 2cm]{geometry}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{eufrak}

\newtheorem*{definition}{Определение}

\lstloadlanguages{C,[ANSI]C++}%,Clean,make,Fortran}%Загружаемые языки
\lstset{extendedchars=false,
        breaklines=true, %автоперенос длинных линий
        breakatwhitespace=true}
\graphicspath{{pic/}}
\titleformat{\chapter}[block]{\color{black}\Large\bfseries\filcenter}{}{1em}{}
\setcounter{secnumdepth}{0}

\begin{document}
\title{Основания алгебраического подхода к синтезу корректных алгоритмов}
\author{Лектор --- Рудаков К.В.\\ Наборщик --- Старожилец В.М.}
\date{}
\maketitle

\tableofcontents

\chapter{Лекция 1}
\section{Введение}
Данные лекции рассматривают общую задачу машинного обучения без привязки к конкретным методам и основы алгебраического подхода к синтезу корректных алгоритмов для её решения. В некотором роде они являются взглядом сверху на задачи машинного обучения и методы их решения.

В первую очередь следует сформулировать задачу машинного обучения в общем виде. По сути это задача построения алгоритма, который реализует отображение из множества начальных информаций в множество конечных информаций. Сразу отметим, что в курсе рассматриваются только такие отображения, для которых существует реализующий их алгоритм.

\begin{definition}
Символом $\mathfrak{I_i}$ (читается <<И инишл>>) будем обозначать множество начальных информаций, например, симптомы болезни.
\end{definition}

\begin{definition}
Символом $\mathfrak{I_f}$ (читается <<И файнэл>>) будем обозначать множество конечных информаций, например, диагноз.
\end{definition}

Таким образом, на формальном языке нам требуется найти такой алгоритм $A$, что он осуществляет отображение из множества начальных информаций $\mathfrak{I_i}$ в множество конечных информаций $\mathfrak{I_f}$:
\[
A: \mathfrak{I_i} \rightarrow \mathfrak{I_f}.
\]
Пока что задача стоит так, что нам нужно найти некоторое произвольное отображение из одного множества в другое, реализуемое некоторым алгоритмом. При этом свойства этого отображения и алгоритма неважны. В такой постановке у нас нет каких-либо ограничений на искомый алгоритм: даже датчик случайных чисел является решением этой задачу. Поэтому вводятся дополнительные ограничения на допустимые алгоритмы. Итак,

\begin{definition}
Обозначим $\mathfrak{M}^* = \{A|\ A:\  \mathfrak{I_i}\rightarrow \mathfrak{I_f}\}$ множество всех алгоритмов, реализующих отображение из $\mathfrak{I_i}$ в $\mathfrak{I_f}$.
\end{definition}

\begin{definition}
Обозначим $I_{str}$ структурную информацию, содержащую условия и требования, накладываемые на $A$.
\end{definition}

\begin{definition}
Обозначим $\mathfrak{M}(I_{str}) \subset \mathfrak{M}^*$ некоторое подмножество $\mathfrak{M}^*$, удовлетворяющее $I_{str}$.
\end{definition}

Теперь у нас есть дополнительная информация $I_{str}$, позволяющий накладывать дополнительные ограничения на нашу задачу. Введём определения допустимого отображения и корректного алгоритма.

\begin{definition}
Любое отображение из множества $\mathfrak{M}(I_{str})$ называется допустимым.
\end{definition}

\begin{definition}
Задача Z заключается в построении алгоритма, реализующего допустимое отображение.
\end{definition}

\begin{definition}
Любой алгоритм реализующий любое допустимое отображение называется корректным.
\end{definition}

В такой формулировке необходимым и достаточным условием разрешимости задачи Z является выполнение выражения: \[
\mathfrak{M}(I_{str}) \neq \emptyset,
\]
а условием единственности решения~--- выполнение равенства:
\[
|\mathfrak{M}(I_{str})| = 1.
\]
Заметим также, что в данной формулировке корректный алгоритм~--- это алгоритм, не допускающий ни одной ошибки, а множество $\mathfrak{M}(I_{str})$~--- множество алгоритмов не допускающих ошибок. Однако можно поставить условия несколько мягче, и дать алгоритмам возможность ошибаться.

\section{Поиск решения задачи}
Пусть $\mathfrak{M}(\pi)$~--- некоторое параметрическое семейство отображений. После того как мы выбрали некоторое семейство отображений $\mathfrak{M}(\pi)$, попытаемся попасть в $\mathfrak{M}(I_{str})$, взяв в $\mathfrak{M}(\pi)$ какое-нибудь отображение за начальное. Это возможно, если данные семейства пересекаются:
\[
\mathfrak{M}(\pi) \cap \mathfrak{M}(I_{str}) \neq \emptyset.
\]

Но, с одной стороны, чем \emph{сложнее} наше семейство, тем выше вероятность, что оно пересекается с семейством $\mathfrak{M}(I_{str})$, однако, с другой стороны, достижение этого пересечения может быть \emph{затратно}, если $\mathfrak{M}(\pi)$ сложное. Также всегда остаётся вероятность, что множество $\mathfrak{M}(\pi)$ с $\mathfrak{M}(I_{str})$ не пересекается. Для поиска компромиссного решения используют идею \emph{расширения множества}.

\begin{definition}
Пусть $f$~--- некоторая операция над множеством $\mathfrak{M}^*$. Тогда $f(\mathfrak{M}(\pi))$ будем называть расширением множества $\mathfrak{M}(\pi)$.
\end{definition}

Таким образом, мы хотим расширить некоторое <<простое>> множество до пересечения с $\mathfrak{M}(I_{str})$. Однако, не любая функция $f$ нам подходит, так как <<простое>> множество может расшириться до слишком <<сложного>> множества. Важно, что $f$ мы выбираем сами, поэтому можем выбрать его так, чтобы искать нужный алгоритм было не слишком сложно.

\chapter{Лекция 2}
Данная лекция скорее просвещена вопросам терминологии в данном курсе. Поэтому, тут будет очень много определений (ещё больше, чем в предыдущей).

\begin{definition}
Сигнатура~---набор характеристик, однозначно идентифицирующий объект.
\end{definition} 

\begin{definition}
Сигнатура~---набор характеристик, однозначно идентифицирующий объект.
\end{definition} 

\begin{definition}
\[
\left(
\begin{array}{cccc}
  A & Op_1 & Op_2... & Op_n \\
  - & n_1 & n_2 & n_3 \\
\end{tabular}
\right)
\]
\end{definition} 
\end{document} 